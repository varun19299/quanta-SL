"""
Profiling for Maximum Likelihood Decoding
"""

import logging

logging.getLogger().setLevel(logging.INFO)
import numpy as np
from einops import rearrange
from types import ModuleType
from nptyping import NDArray
from numba import njit, prange
# from utils.profiler import profile

try:
    import cupy as cp
    from cupy.cuda import memory_hooks
    from cupyx import time

    xp = cp

    CUPY_INSTALLED = True
    logging.info(
        f"CuPy installation found, with {cp.cuda.runtime.getDeviceCount()} GPU(s)."
    )

except ImportError:
    xp = np
    CUPY_INSTALLED = False
    logging.warning("No CuPy installation detected. Using Numpy, may be slow.")


@njit(parallel=True, nogil=True)
def numba_minimum_distance(x, y, hamming_dist_LUT):
    h, w, n, _ = x.shape
    _, _, _, dim_k = y.shape

    z_min = np.zeros((h, w), dtype=np.uint16)

    for i in prange(h):
        for j in prange(w):
            x_vec = x[i, j, :, :].flatten()
            min_dist = 1e8

            for k in range(dim_k):
                y_vec = y[:, :, :, k].flatten()

                dist = 0
                for l in range(n):
                    dist += np.take(hamming_dist_LUT, x_vec[l] ^ y_vec[l])

                if dist < min_dist:
                    z_min[i, j] = k
                    min_dist = dist

    return z_min


# @profile
def minimum_distance(x, y, hamming_dist_LUT: NDArray[int] = None):
    """

    :param x: Shape h, w, n, 1
    :param y: Shape 1, 1, n, 2**k
    :param hamming_dist_LUT: precomputed hamming distance values.
        Useful if x or y are packed as uint8 or uint16.
    :return: Minimum distances h, w, 1 (channel denotes index in 0...2**k -1)
    """

    # duck typing: check if numpy or cupy array
    # See: https://stackoverflow.com/questions/66453371/how-to-ensure-an-argument-is-like-a-numpy-array
    if hasattr(hamming_dist_LUT, "__array_function__"):
        # We are now implementing
        # hamming_dist_LUT[x ^ y].sum(axis=2).argmin(axis=-1)
        # in a memory efficient manner

        h, w, n, _ = x.shape
        _, _, _, dim_k = y.shape

        z = xp.zeros((h, w, n, dim_k), dtype=xp.uint8)

        # Bitwise XOR
        xp.bitwise_xor(x, y, out=z)
        hamming_out = hamming_dist_LUT[z.ravel()]

        hamming_out = rearrange(
            hamming_out,
            "(height width num_bytes samples) -> height width samples num_bytes",
            height=h,
            width=w,
            num_bytes=n,
            samples=dim_k,
        )

        # Save memory. Below 255, we can make do with uint8
        if n < 256:
            summation_out = xp.zeros((h, w, dim_k), dtype=xp.uint8)
        else:
            summation_out = xp.zeros((h, w, dim_k), dtype=xp.uint16)

        # Direct sum seems faster on CuPy
        hamming_out.sum(axis=-1, out=summation_out)

        return summation_out.argmin(axis=-1)

    else:
        h, w, n, _ = x.shape
        _, _, _, dim_k = y.shape

        z = x ^ y
        z = rearrange(
            z, "height width num_bytes samples -> height width samples num_bytes"
        )

        # Matrix mul faster than .sum()
        # https://github.com/numpy/numpy/issues/16158
        vec = np.ones(n, dtype=np.uint8)
        z = xp.matmul(z, vec)

        return z.argmin(axis=-1)


def packbits_strided(bit_array: np.ndarray):
    """
    Pack binary values in strides of 8 (a byte) to uint8.
    We do this to save memory.

    Numpy/ Cupy allocate 1 byte for a boolean, which is 8x higher than needed (1 bit).

    :param bit_array: height x width x num_bits x samples
    :return:
    """
    axis = 2

    # Pad to the left bit_array to nearest multiple of 8
    num_bits = bit_array.shape[axis]
    pad_width = -num_bits % 8

    padding = [(0, 0)] * bit_array.ndim
    padding[axis] = (pad_width, 0)
    bit_array = np.pad(bit_array, padding)

    # Now split into chunks and apply packing
    bit_array = rearrange(
        bit_array,
        "height width (num_bytes bits) samples -> height width num_bytes bits samples",
        bits=8,
    )

    byte_array = np.packbits(bit_array, axis=axis + 1)
    byte_array = rearrange(
        byte_array, "height width num_bytes 1 samples -> height width num_bytes samples"
    )

    return byte_array


def unpackbits_strided(byte_array: np.ndarray, num_bits: int = 0):
    """
    Unpack uint8 array generated by `packbits_strided`
    :param byte_array:
    :param num_bits:
    :return:
    """
    axis = 2

    byte_array = rearrange(
        byte_array, "height width num_bytes samples -> height width num_bytes 1 samples"
    )
    bit_array = np.unpackbits(byte_array, axis=axis + 1)

    # Now combine the chunks
    bit_array = rearrange(
        bit_array,
        "height width num_bytes bits samples -> height width (num_bytes bits) samples",
        bits=8,
    )

    # Slice if needed
    slc = [slice(None)] * bit_array.ndim
    slc[axis] = slice(-num_bits % 8, None)
    return bit_array[slc]


def hamming_distance_8bit(xp: ModuleType = np):
    return xp.array([bin(i).count("1") for i in range(256)], dtype=xp.uint8)


def test_packbits_unpackbits_strided():
    h, w, n, k = 100, 100, 30, 10
    x = np.random.randint(0, 2, (h, w, n, 1), dtype=bool)

    packed_x = packbits_strided(x)
    unpacked_x = unpackbits_strided(packed_x, num_bits=n)

    assert np.array_equal(x, unpacked_x)


def test_minimum_distance():
    h, w, n, k = 30, 30, 30, 10
    x = np.random.randint(0, 2, (h, w, n, 1), dtype=bool)
    y = np.random.randint(0, 2, (1, 1, n, pow(2, k)), dtype=bool)

    dist_binary = minimum_distance(x, y)

    x = packbits_strided(x)
    y = packbits_strided(y)
    dist_packed = minimum_distance(x, y, hamming_dist_LUT=hamming_distance_8bit())

    dist_numba = numba_minimum_distance(x, y, hamming_dist_LUT=hamming_distance_8bit())

    assert np.array_equal(dist_binary, dist_packed)
    assert np.array_equal(dist_binary, dist_numba)


if __name__ == "__main__":
    if CUPY_INSTALLED:
        h, w, n, k = 1024, 512, 30, 10
    else:
        h, w, n, k = 100, 100, 63, 10

    x = np.random.randint(0, 2, (h, w, n, 1), dtype=bool)
    y = np.random.randint(0, 2, (1, 1, n, pow(2, k)), dtype=bool)

    # print(minimum_distance(x, y))

    x = packbits_strided(x)
    y = packbits_strided(y)
    hamming_dist_LUT = hamming_distance_8bit()

    if CUPY_INSTALLED:
        hook = memory_hooks.LineProfileHook()

        with hook:
            x = xp.asarray(x)
            y = xp.asarray(y)
            hamming_dist_LUT = xp.asarray(hamming_dist_LUT)

        hook.print_report()
        # print(time.repeat(minimum_distance, (x, y), n_repeat=10))
        print(time.repeat(minimum_distance, (x, y, hamming_dist_LUT), n_repeat=10))

    else:
        print(minimum_distance(x, y, hamming_dist_LUT))
