"""
Profiling for Maximum Likelihood Decoding
"""

import logging

logging.getLogger().setLevel(logging.INFO)
import numpy as np
from einops import rearrange
from types import ModuleType
from nptyping import NDArray

try:
    import cupy as cp
    from cupy.cuda import memory_hooks

    xp = cp

    CUPY_INSTALLED = True
    logging.info(
        f"CuPy installation found, with {cp.cuda.runtime.getDeviceCount()} GPU(s)."
    )

except ImportError:
    xp = np
    CUPY_INSTALLED = False
    logging.warning("No CuPy installation detected. Using Numpy, may be slow.")


def minimum_distance(x, y, hamming_dist_LUT: NDArray[int] = None):
    """

    :param x: Shape h, w, n, 1
    :param y: Shape 1, 1, n, 2**k
    :param hamming_dist_LUT: precomputed hamming distance values.
        Useful if x or y are packed as uint8 or uint16.
    :return: Minimum distances h, w, 1 (channel denotes index in 0...2**k -1)
    """

    # duck typing: check if numpy or cupy array
    # See: https://stackoverflow.com/questions/66453371/how-to-ensure-an-argument-is-like-a-numpy-array
    if hasattr(hamming_dist_LUT, "__array_function__"):
        # We are now implementing
        # hamming_dist_LUT[x ^ y].sum(axis=2).argmin(axis=-1)
        # in a memory efficient manner

        h, w, n, _ = x.shape
        _, _, _, dim_k = y.shape

        z = xp.zeros((h, w, n, dim_k), dtype=xp.uint8)
        hamming_out = xp.zeros((h, w, n, dim_k), dtype=xp.uint8)

        # Bitwise XOR
        xp.bitwise_xor(x, y, out=z)
        xp.take(hamming_dist_LUT, z, out=hamming_out)

        # Save memory. Below 255, we can make do with uint8
        if n < 256:
            z.fill(0)
            summation_out = z[:, :, 0, :]
        else:
            summation_out = xp.zeros((h, w, dim_k), dtype=xp.uint16)

        xp.sum(hamming_out, axis=2, out=summation_out)
        return summation_out.argmin(axis=-1)

    else:
        return (x ^ y).sum(axis=2).argmin(axis=-1)


def packbits_strided(bit_array: np.ndarray):
    """
    Pack binary values in strides of 8 (a byte) to uint8.
    We do this to save memory.

    Numpy/ Cupy allocate 1 byte for a boolean, which is 8x higher than needed (1 bit).

    :param bit_array: height x width x num_bits x samples
    :return:
    """
    axis = 2

    # Pad to the left bit_array to nearest multiple of 8
    num_bits = bit_array.shape[axis]
    pad_width = -num_bits % 8

    padding = [(0, 0)] * bit_array.ndim
    padding[axis] = (pad_width, 0)
    bit_array = np.pad(bit_array, padding)

    # Now split into chunks and apply packing
    bit_array = rearrange(
        bit_array,
        "height width (num_bytes bits) samples -> height width num_bytes bits samples",
        bits=8,
    )

    byte_array = np.packbits(bit_array, axis=axis + 1)
    byte_array = rearrange(
        byte_array, "height width num_bytes 1 samples -> height width num_bytes samples"
    )

    return byte_array


def unpackbits_strided(byte_array: np.ndarray, num_bits: int = 0):
    """
    Unpack uint8 array generated by `packbits_strided`
    :param byte_array:
    :param num_bits:
    :return:
    """
    axis = 2

    byte_array = rearrange(
        byte_array, "height width num_bytes samples -> height width num_bytes 1 samples"
    )
    bit_array = np.unpackbits(byte_array, axis=axis + 1)

    # Now combine the chunks
    bit_array = rearrange(
        bit_array,
        "height width num_bytes bits samples -> height width (num_bytes bits) samples",
        bits=8,
    )

    # Slice if needed
    slc = [slice(None)] * bit_array.ndim
    slc[axis] = slice(-num_bits % 8, None)
    return bit_array[slc]


def hamming_distance_8bit(xp: ModuleType = np):
    return xp.array([bin(i).count("1") for i in range(256)], dtype=xp.uint8)


def test_packbits_unpackbits_strided():
    h, w, n, k = 100, 100, 30, 10
    x = np.random.randint(0, 2, (h, w, n, 1), dtype=bool)

    packed_x = packbits_strided(x)
    unpacked_x = unpackbits_strided(packed_x, num_bits=n)

    assert np.array_equal(x, unpacked_x)


def test_minimum_distance():
    h, w, n, k = 30, 30, 30, 10
    x = np.random.randint(0, 2, (h, w, n, 1), dtype=bool)
    y = np.random.randint(0, 2, (1, 1, n, pow(2, k)), dtype=bool)

    dist_binary = minimum_distance(x, y)

    x = packbits_strided(x)
    y = packbits_strided(y)
    dist_packed = minimum_distance(x, y, hamming_dist_LUT=hamming_distance_8bit())

    assert np.array_equal(dist_binary, dist_packed)


if __name__ == "__main__":
    if CUPY_INSTALLED:
        h, w, n, k = 1024, 512, 28, 10
    else:
        h, w, n, k = 100, 100, 30, 10

    x = np.random.randint(0, 2, (h, w, n, 1), dtype=bool)
    y = np.random.randint(0, 2, (1, 1, n, pow(2, k)), dtype=bool)

    x = packbits_strided(x)
    y = packbits_strided(y)

    if CUPY_INSTALLED:
        hook = memory_hooks.LineProfileHook()

        with hook:
            x = xp.asarray(x)
            y = xp.asarray(y)
            hamming_dist_LUT = xp.asarray(hamming_distance_8bit())
            minimum_distance(x, y, hamming_dist_LUT)
        hook.print_report()
    else:
        print(minimum_distance(x, y))
