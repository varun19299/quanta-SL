import numpy as np
from einops import rearrange
from math import floor, log2
from types import ModuleType


def _dim_str(dims: int = 1):
    """
    Return string corresponding to array dimensions
    :param array:
    :return:
    """
    return " ".join([f"d_{i}" for i in range(dims)])


def packbits_strided(bit_array: np.ndarray, xp: ModuleType = np):
    """
    Pack binary values in strides of 8 (a byte) to uint8.
    We do this to save memory.
    Last axis assumed to be bits.

    Numpy/ Cupy allocate 1 byte for a boolean, which is 8x higher than needed (1 bit).

    :param bit_array: height x width x num_bits x samples
    :param xp: Numpy or Cupy
    :return:
    """
    axis = -1

    # 1 D grid, 2D grid of values etc
    grid_dim = bit_array.ndim - 1

    # Pad to the left bit_array to nearest multiple of 8
    num_bits = bit_array.shape[axis]
    pad_width = -num_bits % 8

    padding = [(0, 0)] * bit_array.ndim
    padding[axis] = (pad_width, 0)
    bit_array = xp.pad(bit_array, padding)

    # Now split into chunks and apply packing
    bit_array = rearrange(
        bit_array,
        f"{_dim_str(grid_dim)} (num_bytes bits) -> {_dim_str(grid_dim)} num_bytes bits",
        bits=8,
    )

    byte_array = xp.packbits(bit_array, axis=-1)
    byte_array = byte_array.squeeze(axis=-1)

    return byte_array


def unpackbits_strided(byte_array: np.ndarray, num_bits: int = 0, xp: ModuleType = np):
    """
    Unpack uint8 array generated by `packbits_strided`
    Last axis assumed to be bytes

    :param byte_array: array of bytes
    :param num_bits: Since bits are padded to nearest multiple of 8 while packing,
        zero padding can be removed
    :param xp: Numpy or Cupy
    :return:
    """
    assert issubclass(
        byte_array.dtype.type, np.integer
    ), f"Integer array expected, found {byte_array.dtype}"

    # 1 D grid, 2D grid of values etc
    grid_dim = byte_array.ndim - 1

    # Find num bits
    if not num_bits:
        num_bits = floor(log2(byte_array[..., 0].max())) + 1

    byte_array = xp.expand_dims(byte_array, axis=-1)
    bit_array = xp.unpackbits(byte_array, axis=-1)

    # Now combine the chunks
    bit_array = rearrange(
        bit_array,
        f"{_dim_str(grid_dim)} num_bytes bits -> {_dim_str(grid_dim)} (num_bytes bits)",
        bits=8,
    )

    # Slice if needed
    slc = [slice(None)] * bit_array.ndim
    slc[-1] = slice(-num_bits % 8, None)
    return bit_array[slc]
